// https://leetcode.com/explore/interview/card/facebook/52/trees-and-graphs/3026/

use std::collections::VecDeque;

struct Soultion;

impl Soultion {
    pub fn shortest_distance(grid: Vec<Vec<i32>>) -> i32 {
        // let mut houses = Vec::new();
        //
        // for i in 0..grid.len() {
        //     for j in 0..grid[i].len() {
        //         if grid[i][j] == 1 {
        //             houses.push((i, j));
        //         }
        //     }
        // }
        //
        // while let Some((i, j)) = houses.pop() {
        //     let mut queue = VecDeque::new();
        //
        //     queue.push_back((i, j));
        //
        //     while !queue.is_empty() {
        //         let Some((pos_a, pos_b)) = queue.pop_front();
        //     }
        // }
        //
        2
    }
}
